<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RegExp</title>
    <script>
        //切分字符串
        console.log('a b   c'.split(' ')); //[ "a", "b", "", "", "c" ]
        //无法识别的连续空格用正则
        console.log('a b   c'.split(/\s+/)); //[ "a", "b", "c" ]
        console.log('a, b   c'.split(/[\s\,]+/)); //[ "a", "b", "c" ]
        console.log('a,b;;   c d'.split(/[\s\,\;]+/)); //[ "a", "b", "c", "d"]

        //用()表示要提取的分组
        var re = /^(\d{3})-(\d{3,8})$/;
        console.log(re.exec('010-12345')); //[ "010-12345", "010", "12345" ]
        console.log(re.exec('010 12345')); //null

        //贪婪匹配
        var re2 = /^(\d+)(0*)$/;
        console.log(re2.exec('102300')); //[ "102300", "102300", "" ]
        /*由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。
        必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：*/
        var re3 = /^(\d+?)(0*)$/;
        console.log(re3.exec('102300')); //[ "102300", "1023", "00" ]

        //全局搜索
        var r1 = /test/g;
        //等价于
        var r2 = new RegExp('test', 'g');

        /*全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，
        正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：*/
        var s = 'JavaScript, VBScript, JScript and ECMAScript';
        var res = /[a-zA-Z]+Script/g;

        //使用全局匹配
        console.log(res.exec(s)); //[ "JavaScript" ]
        console.log(res.lastIndex); //10
        console.log(res.exec(s)); //[ "VBScript" ]
        console.log(res.lastIndex); //20
        console.log(res.exec(s)); //[ "JScript" ]
        console.log(res.lastIndex); //29
        console.log(res.exec(s)); //[ "ECMAScript" ]
        console.log(res.lastIndex); //44
        console.log(res.exec(s)); //null
    </script>
</head>
<body>

</body>
</html>